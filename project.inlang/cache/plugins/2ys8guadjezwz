import { lookup, ModuleError } from "@inlang/sdk";
import { PostHog } from "posthog-node";
import nodeFsPromises from "node:fs/promises";
import nodePath__default from "node:path";
import crypto from "node:crypto";
import { colors } from "consola/utils";
import consola from "consola";
function escapeForTemplateLiteral(text) {
  return text.replace(/\\/g, "\\\\").replace(/`/g, "\\`").replace(/\${/g, "\\${");
}
function escapeForSingleQuoteString(text) {
  return text.replace(/\\/g, "\\\\").replace(/'/g, "\\'");
}
function escapeForDoubleQuoteString(text) {
  return text.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
}
const KEYWORDS = [
  "break",
  "case",
  "catch",
  "class",
  "const",
  "continue",
  "debugger",
  "default",
  "delete",
  "do",
  "else",
  "export",
  "extends",
  "false",
  "finally",
  "for",
  "function",
  "if",
  "import",
  "in",
  "instanceof",
  "new",
  "null",
  "return",
  "super",
  "switch",
  "this",
  "throw",
  "true",
  "try",
  "typeof",
  "var",
  "void",
  "while",
  "with",
  //Strict mode reserved keywords
  "let",
  "static",
  "yield",
  "await",
  //Reserved keywords for future use
  "enum",
  "implements",
  "interface",
  "package",
  "private",
  "protected",
  "public"
];
function isValidJSIdentifier(str) {
  return !KEYWORDS.includes(str) && canBeUsedAsVariableName(str);
}
function canBeUsedAsVariableName(str) {
  if (str.trim() !== str) {
    return false;
  }
  try {
    new Function(str, "var " + str);
  } catch (_) {
    return false;
  }
  return true;
}
const backtick = (str) => `\`${str}\``;
const compilePattern = (pattern) => {
  let result = "";
  const params = {};
  for (const element of pattern) {
    switch (element.type) {
      case "Text":
        result += escapeForTemplateLiteral(element.value);
        break;
      case "VariableReference":
        if (isValidJSIdentifier(element.name)) {
          result += "${params." + element.name + "}";
        } else {
          result += "${params['" + escapeForSingleQuoteString(element.name) + "']}";
        }
        params[element.name] = "NonNullable<unknown>";
        break;
      default:
        throw new Error("Unknown pattern element type: " + element);
    }
  }
  return {
    params,
    compiled: backtick(result)
  };
};
const paramsType = (params, isMessagesIndex) => {
  if (Object.keys(params).length === 0) {
    return isMessagesIndex ? "@param {{}} params" : "";
  }
  const fieldTypes = [];
  for (const [name, type] of Object.entries(params)) {
    if (isValidJSIdentifier(name)) {
      fieldTypes.push(`${name}: ${type}`);
    } else {
      fieldTypes.push(`'${escapeForSingleQuoteString(name)}': ${type}`);
    }
  }
  return `@param {{ ${fieldTypes.join(", ")} }} params`;
};
function reexportAliases(message) {
  let code = "";
  if (message.alias["default"] && message.id !== message.alias["default"]) {
    code += `
/**
 * Change the reference from the alias \`m.${message.alias["default"]}()\` to \`m.${message.id}()\`:
 * \`\`\`diff
 * - m.${message.alias["default"]}()
 * + m.${message.id}()
 * \`\`\`
 * ---
 * \`${message.alias["default"]}\` is an alias for the message \`${message.id}\`.
 * Referencing aliases instead of the message ID has downsides like:
 *
 * - The alias might be renamed in the future, breaking the code.
 * - Constant naming convention discussions.
 *
 * Read more about aliases and their downsides here 
 * @see inlang.com/link.
 * ---
 * @deprecated reference the message by id \`m.${message.id}()\` instead
 * 
 * @param {Parameters<typeof ${message.id}>} args
 * @returns {ReturnType<typeof ${message.id}>}
 */
export const ${message.alias["default"]} = (...args) => ${message.id}(...args);
`;
  }
  return code;
}
function i(str) {
  var _a;
  str = str.replaceAll(/[^a-zA-Z0-9_]/g, "_");
  if ((_a = str[0]) == null ? void 0 : _a.match(/[0-9]/)) {
    str = "_" + str;
  }
  return str;
}
function toStringUnion(iterable) {
  return [...iterable].map((item) => `"${escapeForDoubleQuoteString(item)}"`).join(" | ");
}
const optionsType = (args) => {
  return `@param {{ languageTag?: ${toStringUnion(args.languageTags) ?? "undefined"} }} options`;
};
const messageIndexFunction = (args) => {
  const hasParams = Object.keys(args.params).length > 0;
  return `/**
 * This message has been compiled by [inlang paraglide](https://inlang.com/m/gerre34r/library-inlang-paraglideJs).
 *
 * - Don't edit the message's code. Use [Sherlock (VS Code extension)](https://inlang.com/m/r7kp499g/app-inlang-ideExtension),
 *   the [web editor](https://inlang.com/m/tdozzpar/app-inlang-finkLocalizationEditor) instead, or edit the translation files manually.
 * 
 * - The params are NonNullable<unknown> because the inlang SDK does not provide information on the type of a param (yet).
 * 
 * ${paramsType(args.params, true)}
 * ${optionsType({ languageTags: args.availableLanguageTags })}
 * @returns {string}
 */
/* @__NO_SIDE_EFFECTS__ */
export const ${args.message.id} = (params ${hasParams ? "" : "= {}"}, options = {}) => {
	return {
${args.availableLanguageTags.sort((a, b) => a.localeCompare(b)).map((tag) => `		${isValidJSIdentifier(tag) ? tag : `"${tag}"`}: ${i(tag)}.${args.message.id}`).join(",\n")}
	}[options.languageTag ?? languageTag()](${hasParams ? "params" : ""})
}
${reexportAliases(args.message)}
`;
};
const compileMessage = (message, fallbackMap, output = "regular") => {
  if (!isValidJSIdentifier(message.id)) {
    throw new Error(
      `Cannot compile message with ID "${message.id}".

The message is not a valid JavaScript variable name. Please choose a different ID.

To detect this issue during linting, use the valid-js-identifier lint rule: https://inlang.com/m/teldgniy/messageLintRule-inlang-validJsIdentifier`
    );
  }
  const compiledPatterns = {};
  let params = {};
  for (const variant of message.variants) {
    if (compiledPatterns[variant.languageTag]) {
      throw new Error(
        `Duplicate language tag: ${variant.languageTag}. Multiple variants for one language tag are not supported in paraglide yet. `
      );
    }
    const { compiled, params: variantParams } = compilePattern(variant.pattern);
    params = { ...params, ...variantParams };
    compiledPatterns[variant.languageTag] = compiled;
  }
  const resource = {
    source: message,
    params,
    index: messageIndexFunction({
      message,
      params,
      availableLanguageTags: Object.keys(fallbackMap)
    }),
    translations: Object.fromEntries(
      Object.entries(fallbackMap).map(([languageTag, fallbackLanguage]) => {
        const compiledPattern = compiledPatterns[languageTag];
        return [
          languageTag,
          compiledPattern ? messageFunction({
            message,
            params,
            languageTag,
            compiledPattern
          }) : fallbackLanguage ? reexportMessage(message, fallbackLanguage, output) : messageIdFallback(message, languageTag)
        ];
      })
    )
  };
  return resource;
};
const messageFunction = (args) => {
  const hasParams = Object.keys(args.params).length > 0;
  return `/**
 * ${paramsType(args.params, false)}
 * @returns {string}
 */
/* @__NO_SIDE_EFFECTS__ */
export const ${args.message.id} = (${hasParams ? "params" : ""}) => ${args.compiledPattern}
${reexportAliases(args.message)}`;
};
function reexportMessage(message, fromLanguageTag, output) {
  const exports = [message.id];
  if (message.alias["default"] && message.id !== message.alias["default"]) {
    exports.push(message.alias["default"]);
  }
  const from = output === "message-modules" ? `../${fromLanguageTag}.js` : `./${fromLanguageTag}.js`;
  return `export { ${exports.join(", ")} } from "${from}"`;
}
function messageIdFallback(message, languageTag) {
  return `/**
 * Failed to resolve message ${message.id} for languageTag "${languageTag}". 
 * @returns {string}
 */
/* @__NO_SIDE_EFFECTS__ */
export const ${message.id} = () => "${escapeForDoubleQuoteString(message.id)}"
${reexportAliases(message)}`;
}
const posthogToken = "phc_m5yJZCxjOGxF8CJvP5sQ3H0d76xpnLrsmiZHduT4jDz";
const posthog = new PostHog(posthogToken, {
  host: "https://eu.posthog.com",
  // Events are not captured if not immediately flushed.
  //
  // Posthog shouldn't batch events because CLI commands
  // are short-lived, see https://posthog.com/docs/libraries/node.
  flushAt: 1,
  flushInterval: 0,
  requestTimeout: 1e3
});
const telemetry = new Proxy(posthog, {
  get(target, prop) {
    if (prop === "capture")
      return capture;
    return target[prop];
  }
});
function capture(args, projectId) {
  const data = {
    ...args,
    distinctId: "unknown",
    groups: projectId ? { project: projectId } : {}
  };
  return posthog.capture(data);
}
const RelevantPackages = [
  "next",
  "solid",
  "solid-start",
  "svelte",
  "@sveltejs/kit",
  "@sveltejs/adaper-static",
  "@sveltejs/adapter-node",
  "@sveltejs/adapter-netlify",
  "@sveltejs/adapter-vercel",
  "@sveltejs/adapter-cloudflare-workers",
  "@sveltejs/adapter-auto",
  "vue",
  "nuxt",
  "react",
  "react-native",
  "remix",
  "astro",
  "flutter",
  "vite",
  "webpack",
  "rollup",
  "esbuild",
  "qwick",
  "parcel",
  "lit",
  "lit-html",
  "@angular/core"
];
function getStackInfo(packageJson) {
  const packages = {};
  try {
    const pkg = packageJson;
    const dependencies = (pkg == null ? void 0 : pkg.dependencies) ?? {};
    const devDependencies = (pkg == null ? void 0 : pkg.devDependencies) ?? {};
    const peerDependencies = (pkg == null ? void 0 : pkg.peerDependencies) ?? {};
    const allDependencies = { ...dependencies, ...devDependencies, ...peerDependencies };
    for (const dependencyName of RelevantPackages) {
      if (dependencyName in allDependencies) {
        const dependencyVersion = allDependencies[dependencyName];
        if (typeof dependencyVersion !== "string")
          continue;
        packages[dependencyName] = dependencyVersion;
      }
    }
    return { packages };
  } catch (error) {
    return { packages };
  }
}
async function pathExists(filePath, nodeishFs) {
  try {
    await nodeishFs.stat(filePath);
    return true;
  } catch (error) {
    if (error.code === "ENOENT") {
      return false;
    } else {
      throw new Error(`Failed to check if path exists: ${error}`, { cause: error });
    }
  }
}
async function findPackageJson(fs, cwd) {
  const potentialPackageJsonPath = nodePath__default.resolve(cwd, "package.json");
  const packageJsonExists = await pathExists(potentialPackageJsonPath, fs);
  if (packageJsonExists)
    return potentialPackageJsonPath;
  return void 0;
}
async function getPackageJson(fs, cwd) {
  const packageJsonPath = await findPackageJson(fs, cwd);
  if (!packageJsonPath)
    return void 0;
  try {
    const packageJsonContents = await fs.readFile(packageJsonPath, { encoding: "utf-8" });
    return JSON.parse(packageJsonContents);
  } catch {
    return void 0;
  }
}
function createRuntime(opts) {
  return `/* eslint-disable */
/** @type {((tag: AvailableLanguageTag) => void) | undefined} */
let _onSetLanguageTag

/**
 * The project's source language tag.
 *
 * @example
 *   if (newlySelectedLanguageTag === sourceLanguageTag){
 *     // do nothing as the source language tag is the default language
 *     return
 *   }
 */
export const sourceLanguageTag = "${opts.sourceLanguageTag}"

/**
 * The project's available language tags.
 *
 * @example
 *   if (availableLanguageTags.includes(userSelectedLanguageTag) === false){
 *     throw new Error("Language tag not available")
 *   }
 */
export const availableLanguageTags = /** @type {const} */ (${JSON.stringify(opts.languageTags)})

/**
 * Get the current language tag.
 *
 * @example
 *   if (languageTag() === "de"){
 *     console.log("Germany ðŸ‡©ðŸ‡ª")
 *   } else if (languageTag() === "nl"){
 *     console.log("Netherlands ðŸ‡³ðŸ‡±")
 *   }
 *
 * @type {() => AvailableLanguageTag}
 */
export let languageTag = () => sourceLanguageTag

/**
 * Set the language tag.
 *
 * @example
 *
 *   // changing to language
 *   setLanguageTag("en")
 *
 *   // passing a getter function also works.
 *   //
 *   // a getter function is useful for resolving a language tag
 *   // on the server where every request has a different language tag
 *   setLanguageTag(() => {
 *     return request.languageTag
 *   })
 *
 * @param {AvailableLanguageTag | (() => AvailableLanguageTag)} tag
 */
export const setLanguageTag = (tag) => {
    if (typeof tag === "function") {
        languageTag = enforceLanguageTag(tag)
    } else {
        languageTag = enforceLanguageTag(() => tag)
    }
    // call the callback function if it has been defined
    if (_onSetLanguageTag !== undefined) {
        _onSetLanguageTag(languageTag())
    }
}

/**
 * Wraps an untrusted function and enforces that it returns a language tag.
 * @param {() => AvailableLanguageTag} unsafeLanguageTag
 * @returns {() => AvailableLanguageTag}
 */
function enforceLanguageTag(unsafeLanguageTag) {
    return () => {
        const tag = unsafeLanguageTag()
        if(!isAvailableLanguageTag(tag)) {
            throw new Error(\`languageTag() didn't return a valid language tag. Check your setLanguageTag call\`)
        }
        return tag
    }
}

/**
 * Set the \`onSetLanguageTag()\` callback function.
 *
 * The function can be used to trigger client-side side-effects such as
 * making a new request to the server with the updated language tag,
 * or re-rendering the UI on the client (SPA apps).
 *
 * - Don't use this function on the server (!).
 *   Triggering a side-effect is only useful on the client because a server-side
 *   environment doesn't need to re-render the UI.
 *
 * - The \`onSetLanguageTag()\` callback can only be defined once to avoid unexpected behavior.
 *
 * @example
 *   // if you use inlang paraglide on the server, make sure
 *   // to not call \`onSetLanguageTag()\` on the server
 *   if (isServer === false) {
 *     onSetLanguageTag((tag) => {
 *       // (for example) make a new request to the
 *       // server with the updated language tag
 *       window.location.href = \`/\${tag}/\${window.location.pathname}\`
 *     })
 *   }
 *
 * @param {(languageTag: AvailableLanguageTag) => void} fn
 */
export const onSetLanguageTag = (fn) => {
    _onSetLanguageTag = fn
}

/**
 * Check if something is an available language tag.
 *
 * @example
 * 	if (isAvailableLanguageTag(params.locale)) {
 * 		setLanguageTag(params.locale)
 * 	} else {
 * 		setLanguageTag("en")
 * 	}
 *
 * @param {any} thing
 * @returns {thing is AvailableLanguageTag}
 */
export function isAvailableLanguageTag(thing) {
    return availableLanguageTags.includes(thing)
}

// ------ TYPES ------

/**
 * A language tag that is available in the project.
 *
 * @example
 *   setLanguageTag(request.languageTag as AvailableLanguageTag)
 *
 * @typedef {typeof availableLanguageTags[number]} AvailableLanguageTag
 */`;
}
const ignoreDirectory = `# ignore everything because the directory is auto-generated by inlang paraglide-js
# for more info visit https://inlang.com/m/gerre34r/paraglide-js
*
`;
const defaultCompileOptions = {
  projectId: void 0,
  outputStructure: "regular"
};
const compile = async (args) => {
  const opts = {
    ...defaultCompileOptions,
    ...args
  };
  const fallbackMap = getFallbackMap(
    opts.settings.languageTags,
    opts.settings.sourceLanguageTag
  );
  const compiledMessages = opts.messages.map(
    (message) => compileMessage(message, fallbackMap, opts.outputStructure)
  );
  const pkgJson = await getPackageJson(nodeFsPromises, process.cwd());
  const stack = getStackInfo(pkgJson);
  telemetry.capture(
    {
      event: "PARAGLIDE-JS compile executed",
      properties: {
        version: "1.11.8",
        stack
      }
    },
    opts.projectId
  );
  const resources = {};
  for (const compiledMessage of compiledMessages) {
    for (const languageTag of Object.keys(compiledMessage.translations)) {
      if (languageTag === "index")
        continue;
      if (!resources[languageTag])
        resources[languageTag] = "";
      resources[languageTag] += "\n\n" + compiledMessage.translations[languageTag];
    }
  }
  const languagesWithMessages = new Set(Object.keys(resources));
  const languagesWithoutMessages = opts.settings.languageTags.filter(
    (languageTag) => !languagesWithMessages.has(languageTag)
  );
  for (const languageTag of languagesWithoutMessages) {
    if (!resources[languageTag])
      resources[languageTag] = "\n\nexport {};";
  }
  telemetry.shutdown();
  let output = {
    // boilerplate files
    ".prettierignore": ignoreDirectory,
    ".gitignore": ignoreDirectory,
    "runtime.js": createRuntime(opts.settings)
  };
  if (opts.outputStructure === "message-modules") {
    for (const message of compiledMessages) {
      output[`messages/index/${message.source.id}.js`] = [
        "/* eslint-disable */",
        'import { languageTag } from "../../runtime.js"',
        opts.settings.languageTags.map(
          (languageTag) => `import * as ${i(languageTag)} from "../${languageTag}/${message.source.id}.js"`
        ).join("\n"),
        "\n",
        message.index
      ].join("\n");
      for (const [lang, source] of Object.entries(message.translations)) {
        output[`messages/${lang}/${message.source.id}.js`] = [
          "/* eslint-disable */",
          `/** 
* This file contains language specific message functions for tree-shaking. 
* 
*! WARNING: Only import messages from this file if you want to manually
*! optimize your bundle. Else, import from the \`messages.js\` file. 
* 
* Your bundler will (in the future) automatically replace the index function 
* with a language specific message function in the build step. 
*/`,
          source
        ].join("\n");
      }
    }
    const messageIDs = compiledMessages.map((message) => message.source.id);
    output["messages.js"] = [
      "/* eslint-disable */",
      ...messageIDs.map((id) => `export * from "./messages/index/${id}.js"`)
    ].join("\n");
    for (const languageTag of opts.settings.languageTags) {
      output[`messages/${languageTag}.js`] = [
        "/* eslint-disable */",
        ...messageIDs.length === 0 ? ["export {}"] : messageIDs.map((id) => `export * from "./${languageTag}/${id}.js"`)
      ].join("\n");
    }
  } else {
    output = {
      ...output,
      // message index file
      "messages.js": [
        "/* eslint-disable */",
        'import { languageTag } from "./runtime.js"',
        opts.settings.languageTags.map((languageTag) => `import * as ${i(languageTag)} from "./messages/${languageTag}.js"`).join("\n"),
        "\n",
        compiledMessages.map((message) => message.index).join("\n\n")
      ].join("\n"),
      ...Object.fromEntries(
        Object.entries(resources).map(([languageTag, content]) => [
          `messages/${languageTag}.js`,
          [
            "/* eslint-disable */",
            `/** 
 * This file contains language specific message functions for tree-shaking. 
 * 
 *! WARNING: Only import messages from this file if you want to manually
 *! optimize your bundle. Else, import from the \`messages.js\` file. 
 * 
 * Your bundler will (in the future) automatically replace the index function 
 * with a language specific message function in the build step. 
 */`,
            content
          ].join("\n")
        ])
      )
    };
  }
  return output;
};
function getFallbackMap(languageTags, sourceLanguageTag) {
  return Object.fromEntries(
    languageTags.map((lang) => {
      const fallbackLanguage = lookup(lang, {
        languageTags: languageTags.filter((t) => t !== lang),
        defaultLanguageTag: sourceLanguageTag
      });
      if (lang === fallbackLanguage)
        return [lang, void 0];
      else
        return [lang, fallbackLanguage];
    })
  );
}
let previousOutputHash;
async function writeOutput(outputDirectory, output, fs) {
  const currentOutputHash = hashOutput(output, outputDirectory);
  if (currentOutputHash === previousOutputHash)
    return;
  await fs.access(outputDirectory).catch(async () => {
    await fs.mkdir(outputDirectory, { recursive: true });
  });
  const files = await fs.readdir(outputDirectory);
  await Promise.allSettled(
    files.map(async (file) => {
      await fs.unlink(outputDirectory + "/" + file);
    })
  );
  await Promise.allSettled(
    Object.keys(output).map(async (filePath) => {
      const fullPath = nodePath__default.resolve(outputDirectory, filePath);
      const directory = nodePath__default.dirname(fullPath);
      await fs.mkdir(directory, { recursive: true });
    })
  );
  await Promise.allSettled(
    Object.entries(output).map(async ([filePath, fileContent]) => {
      const fullPath = nodePath__default.resolve(outputDirectory, filePath);
      await fs.writeFile(fullPath, fileContent);
    })
  );
  previousOutputHash = currentOutputHash;
}
function hashOutput(output, outputDirectory) {
  const hash = crypto.createHash("sha256");
  hash.update(JSON.stringify(output));
  hash.update(outputDirectory);
  return hash.digest("hex");
}
consola.options = {
  ...consola.options,
  formatOptions: { date: false }
};
class Logger {
  constructor(options = { silent: false, prefix: true }) {
    this.options = options;
  }
  /**
   * Prints an empty line to the console.
   */
  ln() {
    if (this.options.silent)
      return this;
    console.log("");
    return this;
  }
  log(message) {
    if (this.options.silent)
      return this;
    const prefix = this.options.prefix ? colors.bold("[paraglide] ") : "";
    consola.log(prefix + message);
    return this;
  }
  info(message) {
    if (this.options.silent)
      return this;
    const prefix = this.options.prefix ? colors.bold(colors.blue("[paraglide] ")) : "";
    consola.info(prefix + message);
    return this;
  }
  success(message) {
    if (this.options.silent)
      return this;
    const prefix = this.options.prefix ? colors.bold(colors.green("[paraglide] ")) : "";
    consola.success(prefix + message);
    return this;
  }
  warn(message, ...args) {
    consola.warn(message, ...args);
    return this;
  }
  error(message, ...args) {
    consola.error(message, ...args);
    return this;
  }
  box(message, ...args) {
    if (this.options.silent)
      return this;
    consola.box(message, ...args);
    return this;
  }
}
function classifyProjectErrors(errors) {
  const isModuleError = (err) => err instanceof ModuleError;
  const [moduleErrors, otherErrors] = split(errors, isModuleError);
  const isFatalModuleError = (err) => err.module.includes("plugin");
  const [fatalModuleErrors, nonFatalModuleErrors] = split(moduleErrors, isFatalModuleError);
  const fatalErrors = [...fatalModuleErrors, ...otherErrors];
  const nonFatalErrors = [...nonFatalModuleErrors];
  return { fatalErrors, nonFatalErrors };
}
function split(array, predicate) {
  const mask = array.map(predicate);
  const result = array.filter((_, index) => mask[index]);
  const rest = array.filter((_, index) => !mask[index]);
  return [result, rest];
}
export {
  Logger,
  classifyProjectErrors,
  compile,
  findPackageJson as f,
  pathExists as p,
  telemetry as t,
  writeOutput
};
